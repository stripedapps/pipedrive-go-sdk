/*
Pipedrive API v1

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ItemSearchAPIService ItemSearchAPI service
type ItemSearchAPIService service

type ApiSearchItemRequest struct {
	ctx context.Context
	ApiService *ItemSearchAPIService
	term *string
	itemTypes *string
	fields *string
	searchForRelatedItems *bool
	exactMatch *bool
	includeFields *string
	start *int32
	limit *int32
}

// The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
func (r ApiSearchItemRequest) Term(term string) ApiSearchItemRequest {
	r.term = &term
	return r
}

// A comma-separated string array. The type of items to perform the search from. Defaults to all.
func (r ApiSearchItemRequest) ItemTypes(itemTypes string) ApiSearchItemRequest {
	r.itemTypes = &itemTypes
	return r
}

// A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Project&lt;/td&gt;&lt;td&gt; &#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;, &#x60;description&#x60; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
func (r ApiSearchItemRequest) Fields(fields string) ApiSearchItemRequest {
	r.fields = &fields
	return r
}

// When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization
func (r ApiSearchItemRequest) SearchForRelatedItems(searchForRelatedItems bool) ApiSearchItemRequest {
	r.searchForRelatedItems = &searchForRelatedItems
	return r
}

// When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
func (r ApiSearchItemRequest) ExactMatch(exactMatch bool) ApiSearchItemRequest {
	r.exactMatch = &exactMatch
	return r
}

// A comma-separated string array. Supports including optional fields in the results which are not provided by default.
func (r ApiSearchItemRequest) IncludeFields(includeFields string) ApiSearchItemRequest {
	r.includeFields = &includeFields
	return r
}

// Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
func (r ApiSearchItemRequest) Start(start int32) ApiSearchItemRequest {
	r.start = &start
	return r
}

// Items shown per page
func (r ApiSearchItemRequest) Limit(limit int32) ApiSearchItemRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchItemRequest) Execute() (*SearchItemResponse200, *http.Response, error) {
	return r.ApiService.SearchItemExecute(r)
}

/*
SearchItem Perform a search from multiple item types

Performs a search from your choice of item types and fields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchItemRequest
*/
func (a *ItemSearchAPIService) SearchItem(ctx context.Context) ApiSearchItemRequest {
	return ApiSearchItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchItemResponse200
func (a *ItemSearchAPIService) SearchItemExecute(r ApiSearchItemRequest) (*SearchItemResponse200, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchItemResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemSearchAPIService.SearchItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/itemSearch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.term == nil {
		return localVarReturnValue, nil, reportError("term is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "")
	if r.itemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "item_types", r.itemTypes, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.searchForRelatedItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_for_related_items", r.searchForRelatedItems, "")
	}
	if r.exactMatch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exact_match", r.exactMatch, "")
	}
	if r.includeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_fields", r.includeFields, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchItemByFieldRequest struct {
	ctx context.Context
	ApiService *ItemSearchAPIService
	term *string
	fieldType *string
	fieldKey *string
	exactMatch *bool
	returnItemIds *bool
	start *int32
	limit *int32
}

// The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
func (r ApiSearchItemByFieldRequest) Term(term string) ApiSearchItemByFieldRequest {
	r.term = &term
	return r
}

// The type of the field to perform the search from
func (r ApiSearchItemByFieldRequest) FieldType(fieldType string) ApiSearchItemByFieldRequest {
	r.fieldType = &fieldType
	return r
}

// The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields&#39; API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
func (r ApiSearchItemByFieldRequest) FieldKey(fieldKey string) ApiSearchItemByFieldRequest {
	r.fieldKey = &fieldKey
	return r
}

// When enabled, only full exact matches against the given term are returned. The search &lt;b&gt;is&lt;/b&gt; case sensitive.
func (r ApiSearchItemByFieldRequest) ExactMatch(exactMatch bool) ApiSearchItemByFieldRequest {
	r.exactMatch = &exactMatch
	return r
}

// Whether to return the IDs of the matching items or not. When not set or set to &#x60;0&#x60; or &#x60;false&#x60;, only distinct values of the searched field are returned. When set to &#x60;1&#x60; or &#x60;true&#x60;, the ID of each found item is returned.
func (r ApiSearchItemByFieldRequest) ReturnItemIds(returnItemIds bool) ApiSearchItemByFieldRequest {
	r.returnItemIds = &returnItemIds
	return r
}

// Pagination start
func (r ApiSearchItemByFieldRequest) Start(start int32) ApiSearchItemByFieldRequest {
	r.start = &start
	return r
}

// Items shown per page
func (r ApiSearchItemByFieldRequest) Limit(limit int32) ApiSearchItemByFieldRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchItemByFieldRequest) Execute() (*SearchItemByFieldResponse200, *http.Response, error) {
	return r.ApiService.SearchItemByFieldExecute(r)
}

/*
SearchItemByField Perform a search using a specific field from an item type

Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchItemByFieldRequest
*/
func (a *ItemSearchAPIService) SearchItemByField(ctx context.Context) ApiSearchItemByFieldRequest {
	return ApiSearchItemByFieldRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchItemByFieldResponse200
func (a *ItemSearchAPIService) SearchItemByFieldExecute(r ApiSearchItemByFieldRequest) (*SearchItemByFieldResponse200, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchItemByFieldResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemSearchAPIService.SearchItemByField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/itemSearch/field"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.term == nil {
		return localVarReturnValue, nil, reportError("term is required and must be specified")
	}
	if r.fieldType == nil {
		return localVarReturnValue, nil, reportError("fieldType is required and must be specified")
	}
	if r.fieldKey == nil {
		return localVarReturnValue, nil, reportError("fieldKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "field_type", r.fieldType, "")
	if r.exactMatch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exact_match", r.exactMatch, "")
	} else {
		var defaultValue bool = false
		r.exactMatch = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "field_key", r.fieldKey, "")
	if r.returnItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "return_item_ids", r.returnItemIds, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
